:toc: macro
toc::[]

= Production Line

== Introduction

The _continuous delivery_ is a software engineering approach in which teams produce software in short cycles, ensuring that the software can be reliably released at any time. It aims at building, testing, and releasing software faster and more frequently. The approach helps reduce the cost, time, and risk of delivering changes by allowing for more incremental updates to applications in production.

Continuous delivery treats the notion of a _deployment pipeline_ based on a _mistake-proofing_ approach: a set of validations through which a piece of software must pass on its way to release. Code is compiled if necessary and then packaged by a build server every time a change is committed to a source control repository, then tested by a number of different techniques (possibly including manual testing) before it can be marked as releasable.

image::images/productionline/ci-process-diagram.png[,width="450", link="images/productionline/ci-process-diagram.png"]

== Devonfw Continuous Integration Infrastructure

The previous concept is applied in the context of Devon with Jenkins as the core of the process and a set of tools surrounding it.

The following schema shows the infrastructure of the tools used for the Devonfw Continuous Integration and their relations. link::https://jenkins.io/[Jenkins] for instance, as we just mentioned the core of _continuous integration_, gets triggered by possible changes in a Github repository. It then builds the project using _Maven_ and the resulting artifacts can be either deployed to a _Nexus_ repository or to a app container (Docker, Tomcat). During the integration process a SonarQube instance manages the project's source quality.

image::images/productionline/pl-schema.png[,width="450", link="images/productionline/pl-schema.png"]

=== Git
link::https://git-scm.com/[Git] is a version control system that helps a software team manage changes to a source code over time. Version control software keeps track of every modification to the code. It allows returning back restoring earlier versions of the code or working on parallel features of software using branches.

=== Gerrit
link::https://www.gerritcodereview.com/[Gerrit] is a code colaboration tool. It hosts the Git repository and extends available functionality. Implements voting protocol allowing automated code review by software tools as well as manual acceptance by a reviewer.

Gerrit can be placed in between the repository and the user’s code push request to provide the ability to discuss a change before submitting.

=== Jenkins
link::https://jenkins.io/[Jenkins] is an automation engine with an great plugin ecosystem to support the majority of tools surrounding _continuous integration_, _automated testing_ or _continuous delivery_. It provides tools for scheduling and automating the whole build process for the Devonfw apps managing the trigger and build processes.

=== SonarQube
link::http://www.sonarqube.org/[SonarQube] is a tool for continuous inspection of code quality, preventing redundancies, complexity and aiming to approach to code conventions and good practices. It performs static code analysis and allows gathering reports of various tests performed on application. Provides a single point with web GUI, where developers can check the test results.

=== Maven
link::https://maven.apache.org/[Maven] is a build automation tool used primarily for Java projects. Was originally created to standarize a clear definition of how to build ANT projects. After time, thanks to community support and its plugin system, it evolved into a fully functional JAVA project management system. Within the _continuous integration_ the build process of the DevonFW applications is executed through Maven and only initiated by Jenkins.

=== Nexus
link::http://www.sonatype.org/nexus/[Nexus] is a repository providing centralized storage place for the JAVA artifacts – JAR / WAR files containing built applications.

=== Tomcat
link::http://tomcat.apache.org/[Tomcat] is an open-source Java Servlet Container that implements several Java EE specifications including Java Servlet, JavaServer Pages (JSP), Java EL, and WebSocket, and provides a "pure Java" HTTP web server environment in which Java code can run.

=== Docker
link::https://www.docker.com/[Docker] is a lightweight virtualization software allowing wrapping applications into containers – running images with all the prerequisites and dependencies needed for the application to run. By letting go of operating system burden, through usage of underlying host operating system, Docker containers can be started almost instantly. Docker provides additionally a set of tools that support management of the containers, hosting image repositories and many others.

== The Production Line
The Production Line provides access to all these tools over the Production Line interface on http://devon.s2-eu.capgemini.com.

After logging in, the tools can be accessed over a drop down menu (called _Services_) in the top menu bar.

=== Prerequisites
To implement the Production Line in your project you only need:

- a Production Line instance.
- a Remote Linux host for deployment.

== Introduction to the Production Line implementation in a Devon app

=== Continuous Delivery Pipeline
While preparing a process of automated build and testing, a good practice is to organize the development processes from the project into the form of the pipeline, that provides a clear view of its stages. This pipeline is reflected in Jenkins job stages and facilitates organization and issue identification.

Below you can find the _continuous delivery_ pipeline used in a basic Devonfw app.

image::images/productionline/pl-pipeline.png[,width="550", link="images/productionline/pl-pipeline.png"]

1.	Code commits into source version control tool trigger the Jenkins job. Alternatively it can be triggered manually.
2.	The environment is prepared for the deployment – the prerequisites are checked and provisioned if not met.
3.	Code is being built using Maven. During the build, the code checking tests are executed.
4.	When the tests are finished successfully, the artifact and Docker ready image aresent to the repository, ready to be deployed on the staging environment.
5.	When the environment is ready, Jenkins automatically deploys image from the repository.
6.	After the application deployment, automatic tests are executed for verification of actual version on test instance.
7.	After the whole process, the environment is cleared, releasing hardware resources for the next run.


In terms of tools the previous schema could be represented as

image::images/productionline/pl-pipelinetools.png[,width="550", link="images/productionline/pl-pipelinetools.png"]

