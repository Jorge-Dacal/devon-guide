:toc: macro
toc::[]

= Writing Unit Test Cases

== Unit Test

In computer programming, unit testing is a software testing method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures, are tested to determine whether they are fit for use. Intuitively, one can view a unit as the smallest testable part of an application. For more information visit https://en.wikipedia.org/wiki/Unit_testing[wikipedia].

=== Unit Test on Eclipse

In order to understand how work the Unit Tests in Eclipse, we are going to create and run a simple tests.

==== Step 1: Create a new class

In this little tutorial we are going to create a very simple test. For this, we are going to create a class with the name MyClass.java (you can https://github.com/devonfw/devon-guide/wiki/getting-started-creating-new-devonfw-application[create a new application] if you need). In Eclipse do right click in the package of the application > New > Class. Name it MyClass and press Finish.

==== Step 2: Create a JUnit test

In Project Explorer, over our new MyClass.java class, we need to do right click > New > Other > and select JUnit Test Case. Name it MyClassTest (name by default) and select source folder and package of your application where you want to create the test, e.g. `src/test/java` (this is a good practice). 

==== Step 3: Implement the test

In a OASP4J project we have our own Component Test methods, so we need to do that our new JUnit Test extends of ComponentTest of the OASP4J module test.

Fist of all check if you have the dependency of the module in your pom.xml

[source,xml]
----
<dependency>
  <groupId>io.oasp.java.modules</groupId>
  <artifactId>oasp4j-test</artifactId>
  <scope>test</scope>
</dependency>
----

Now we can modify our JUnit Test.

[source,java]
----
@SpringApplicationConfiguration(classes = { SpringBootApp.class })
public class MyClassTest extends ComponentTest {

  @Test
  public void test() {
    assertThat(false).isTrue();
  }
}
----

This is a very simple test that verify if the boolean value `true` is true. And is the case to start testing OASP4J application.

[NOTE]
=====
As you can see we are including the `@SpringApplicartionContext` annotation in order to define an application context to our test. Without the context the application, the test get a fatal error, because you can't test a non-running application. 

We can include a configuration location in the last annotation, if we need it, or use `@ContextConfiguration(locations = { "classpath:my-bean-context.xml" })`. For this tutorial it's unnecessary because our test is the most very simple test we can do.
=====

==== Step 4: Run the test

Eclipse provide us with a very helpful view to test our applications. If you can't see it press in the menu: Windows > Show View > Other > and select JUnit. 

Now, over our test, press right click > Run As > JUnit test

image::images/writing-unittest-cases/getting-started-writing-unittest-cases-failed.png[,scaledwidth=80%]

As you can see in the image, Eclipse show us a red rectangle because one of the test of our test class get a failure (in this case we have a single test). The failures test are marked with a blue cross. We can get three marks:

* Red cross: the test has some fatal error as, e.g context error, null pointer exceptions, etc.
* Blue cross: the test fail in some test method like `asserThan()` (like our case)
* Green check: the test is OK

In this, we have a very simple failure, because in the test we have `assertThat(false).isTrue()` that is the same as check if `true == false`. Now, we are going to fix the failure and run the test again.

[source,java]
----
@SpringApplicationConfiguration(classes = { SpringBootApp.class })
public class MyClassTest extends ComponentTest {

  @Test
  public void test() {
    assertThat(true).isTrue();
  }
}
----

Now we need to run the test again. And we are going to get the next result

image::images/writing-unittest-cases/getting-started-writing-unittest-cases-ok.png[,scaledwidth=80%]

As you can see, now the test is success and Eclipse show us a green rectangle and the test with a green check.

Now we can start testing all our applications 

== Test-driven development (TDD) 

Test-driven development (TDD) is a software development process that relies on the repetition of a very short development cycle: first the developer writes an (initially failing) automated test case that defines a desired improvement or new function, then produces the minimum amount of code to pass that test, and finally refactors the new code to acceptable standards.

The procedure of doing TDD is following:

* Create a test
* Run all tests
* Write the implementation code
* Run all tests
* Refactor

=== TDD tutorial with Eclipse

Now, that we know how to create, write and run a test, we can start understanding the last steps with a tutorial in order to get the most clear idea about TDD.

The goal is create a very simple calculator that have 2 methods: add(int,int) and sub(int,int).

==== Step 1: Create a test

The idea is very simple, we are going to create first the tests for the class that we are going to implement after. That allow us to get the control of the result of our work and verify from the beginning that our code is correct.

We need to create a test called `CalculatorTest` in our test package and our class `Calculator` in our java package. 

In this test class we are going to include a variable of our class Calculator and the test to the future add() and sub() methods of Calculator class.

Calculator.java
[source,java]
----
public class Calculator {
  public Calculator() {}

  public Object add(int a, int b) {
    return null;
  }

  public Object sub(int a, int b) {
    return null;
  }
}
----

As you can see in this case we have the wire of our calculator, in this case the implementations is very simple but you can scale this to a very big application. Now we need to include in the class CalculatTest the result we want to get when we finish the implementation of our Calculator.

CalculatorTest.java
[source,java]
----
@SpringApplicationConfiguration(classes = { SpringBootApp.class })
public class CalculatorTest extends ComponentTest {
  private Calculator calculator = new Calculator();

  @Test
  public void addTest() {
    assertThat(this.calculator.add(1, 2)).isEqualTo(3);
  }

  @Test
  public void subTest() {
    assertThat(this.calculator.sub(1, 2)).isEqualTo(-1);
  }
}
----

==== Step 2: Run the test

Run the test and this should be the result

image::images/writing-unittest-cases/getting-started-writing-unittest-cases-TDD-failed.png[,scaledwidth=80%]

As you can see the test get some failures, is the expected because the Calculator doesn't work yet. 

The fact is that this is more a metaphoric step, we are implementing this tests and is obvious that we will get errors if we run it. But this is the cycle of TDD, we write the test that it will, obviously, fail and we write the code that satisfy this test and don't get error. That help us to make sure that our code is strong and success the test.

[NOTE]
=====
As you can see in the methods `add()` and `sub()` we are returning an `Object`, this is because if the methods return an `int` now, we get a "red error" of `NullPointerException` instead of "blue error" of `assetThat()`. It's just for this tutorial.
=====

==== Step 3: Write the implementation code

For now, we have a very awesome test and an awful implementation of our Calculator, so we need to implement it now.

Lest's go to implement the method `add()` and see what's happen

[source,java]
----
 public class Calculator {
  public Calculator() {}

  public int add(int a, int b) {
    return a + b;
  }

  public Object sub(int a, int b) {
    return null;
  }
}
----

==== Step 4: Run the test

If you run now the test you get the next result

image::images/writing-unittest-cases/getting-started-writing-unittest-cases-TDD-failed2.png[,scaledwidth=80%]

Now we have a success result for the method `add()` and a failure result for the method `sub()`. As you can see it's not necessary that we get all test OK to run the tests, we can check whenever we want the result of the test and work to satisfy it. This is, again the idea of TDD.

==== Step 5: Refactor

Now we finally we need to implement the method `sub()`

[source,java]
----
public class Calculator {
  public Calculator() {}

  public int add(int a, int b) { 
    return a + b;
  }

  public int sub(int a, int b) { 
    return a - b;
  }
}
----

==== Step 6: Run the test (return to step 2)

If we run now the application we can see the next result

image::images/writing-unittest-cases/getting-started-writing-unittest-cases-TDD-ok.png[,scaledwidth=80%]

Finally we have our first application implemented with TDD methodology!

As you can see, in this tutorial we have a very simple application, so we donâ€™t need another round of the TDD cycle, but in a real application, we need to do this cycle the times we need to get the success result.

