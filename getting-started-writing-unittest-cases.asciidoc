:toc: macro
toc::[]

= Writing Unit Test Cases

== Unit Test

In computer programming, unit testing is a software testing method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures, are tested to determine whether they are fit for use. Intuitively, one can view a unit as the smallest testable part of an application. For more information visit https://en.wikipedia.org/wiki/Unit_testing[wikipedia].

=== Unit Test on Eclipse

In order to understand how the Unit Tests work in Eclipse we are going to create and run a simple test.

==== Step 1: Create a new class

Create a class with the name _MyClass.java_ (you can https://github.com/devonfw/devon-guide/wiki/getting-started-creating-new-devonfw-application[create a new application] if you need). In Eclipse do right click in the package of the application and then select _New > Class_. Name it _MyClass_ and press _Finish_.

==== Step 2: Create a JUnit test

In Project Explorer, over our new _MyClass.java class_, we need to do right click and then _New > Other >_ and select _JUnit Test Case_. Name it _MyClassTest_ (name by default) and select source folder and package of your application where you want to create the test, e.g. `src/test/java` (this is a good practice). 

==== Step 3: Implement the test
Fist of all check if you have the dependency of the module in your project's _pom.xml_ file.

[source,xml]
----
<dependency>
  <groupId>io.oasp.java.modules</groupId>
  <artifactId>oasp4j-test</artifactId>
  <scope>test</scope>
</dependency>
----

In a OASP4J project we have our own Component Test methods, so we need our new _JUnit Test_ class to extend _ComponentTest_ class of the OASP4J module test.

[source,java]
----
@SpringApplicationConfiguration(classes = { SpringBootApp.class })
public class MyClassTest extends ComponentTest {

  @Test
  public void test() {
    assertThat(false).isTrue();
  }
}
----

This is a very simple test that verifies if the boolean value `true` is true. And is the case to start testing OASP4J application. As you can imagine our test is going to fail but we will see it later.

[NOTE]
=====
As you can see we are including the `@SpringApplicartionContext` annotation in order to define an application context to our test. Without the context of the application, the test gets a fatal error, because you can't test a non-running application. 

We can include a configuration location in the last annotation, if we need it, or use `@ContextConfiguration(locations = { "classpath:my-bean-context.xml" })`. For this tutorial it's unnecessary because our test is the most very simple test we can do.
=====

==== Step 4: Run the test

Eclipse provide us with a very helpful view to test our applications. If you can't see it press the menu: _Windows > Show View > Other_ and select _JUnit_. 

Now, over our test, press right click _Run As > JUnit test_

image::images/writing-unittest-cases/getting-started-writing-unittest-cases-failed.png[,width="450", link="https://github.com/devonfw/devon-guide/wiki/images/writing-unittest-cases/getting-started-writing-unittest-cases-failed.png"]

As you can see in the image, Eclipse shows us a red rectangle because one of the test of our test class has failed (in this case we have a single test). The fails of a test are marked with a blue cross but we can get three marks:

* Red cross: the test has some fatal error as, e.g context error, null pointer exceptions, etc.
* Blue cross: the test fails in some test method like `asserThan()` (like our case)
* Green check: the test is OK

In our case we have a very simple failure because in the test we have `assertThat(false).isTrue()` that is the same as check if `true == false`. Now, we are going to fix the failure and run the test again.

[source,java]
----
@SpringApplicationConfiguration(classes = { SpringBootApp.class })
public class MyClassTest extends ComponentTest {

  @Test
  public void test() {
    assertThat(true).isTrue();
  }
}
----

Now we need to run the test again. And we are going to get the next result

image::images/writing-unittest-cases/getting-started-writing-unittest-cases-ok.png[,width="450", link="https://github.com/devonfw/devon-guide/wiki/images/writing-unittest-cases/getting-started-writing-unittest-cases-ok.png"]

As you can see, now the test ends successfully and Eclipse show us a green rectangle and the test with a green check.

With this knowledge base we can start testing all our applications. 

== Test-driven development (TDD)

Test-driven development (TDD) is a software development process that relies on the repetition of a very short development cycle: first the developer writes an (initially failing) automated test case that defines a desired improvement or new function, then produces the minimum amount of code to pass that test, and finally refactors the new code to acceptable standards.

The procedure of doing TDD is following:

* Create a test
* Run all tests
* Write the implementation code
* Run all tests
* Refactor

=== TDD on Eclipse

Now that we know how to create, write and run a test, we can start with a simple tutorial in order to get the most clear idea about TDD.

The goal is create a very simple calculator that has 2 methods: add(int,int) and sub(int,int).

==== Step 1: Create a test

The idea is very simple, first we are going to create the tests for the methods of a class that we are going to implement after. That allow us to get the control of the result of our work and verify from the beginning that our code is working properly.

We need to create a test called `CalculatorTest` in our test package and our class `Calculator` in our java package. 

In this test class we are going to include a variable of our class _Calculator_ and the test to the future _add()_ and _sub()_ methods of _Calculator_ class.

Calculator.java
[source,java]
----
public class Calculator {
  public Calculator() {}

  public Object add(int a, int b) {
    return null;
  }

  public Object sub(int a, int b) {
    return null;
  }
}
----

As you can see we have the wire of our calculator, in this case the implementations is very simple but you can scale this to a more complex logic. Now we need to include in the class _CalculatorTest_ the result we want to get when we finished the implementation of our Calculator.

CalculatorTest.java
[source,java]
----
@SpringApplicationConfiguration(classes = { SpringBootApp.class })
public class CalculatorTest extends ComponentTest {
  private Calculator calculator = new Calculator();

  @Test
  public void addTest() {
    assertThat(this.calculator.add(1, 2)).isEqualTo(3);
  }

  @Test
  public void subTest() {
    assertThat(this.calculator.sub(1, 2)).isEqualTo(-1);
  }
}
----

==== Step 2: Run the test new test

Run the test and this should be the result

image::images/writing-unittest-cases/getting-started-writing-unittest-cases-TDD-failed.png[,width="450", link="https://github.com/devonfw/devon-guide/wiki/images/writing-unittest-cases/getting-started-writing-unittest-cases-TDD-failed.png"]

Obviously the test gets some failures, is the expected because the Calculator doesn't work yet. 

The fact is that this is more a metaphoric step, we are implementing this tests and is obvious that we will get errors if we run it. But this is the cycle of TDD, we write a test that will, obviously, fail and then we write the code to satisfy the test. That help us to make sure that our code is strong.

[NOTE]
=====
As you can see in the methods `add()` and `sub()` we are returning an `Object`, this is because if the methods return an `int` now, we get a "red error" of `NullPointerException` instead of "blue error" of `assetThat()`. It's just for this tutorial.
=====

==== Step 3: Write the implementation code

Until now we have a very awesome test and an awful implementation of our Calculator, so we need to implement it now.

Lest's go to implement the method `add()` and see what happens.

[source,java]
----
 public class Calculator {
  public Calculator() {}

  public int add(int a, int b) {
    return a + b;
  }

  public Object sub(int a, int b) {
    return null;
  }
}
----

==== Step 4: Run the test -again-

If you run now the test you will get the next result

image::images/writing-unittest-cases/getting-started-writing-unittest-cases-TDD-failed2.png[,width="450", link="https://github.com/devonfw/devon-guide/wiki/images/writing-unittest-cases/getting-started-writing-unittest-cases-TDD-failed2.png"]

Now we have a success result for the method `add()` and a failure result for the method `sub()`. As you can see it's not necessary that we get all test OK to run the tests, we can check whenever we want the result of the test and work to satisfy it. This is, again, the idea of TDD.

==== Step 5: Refactor

Now we finally need to implement the method `sub()`

[source,java]
----
public class Calculator {
  public Calculator() {}

  public int add(int a, int b) { 
    return a + b;
  }

  public int sub(int a, int b) { 
    return a - b;
  }
}
----

==== Step 6: Run the test -return to step 2-

If we run now the application we can see the next result

image::images/writing-unittest-cases/getting-started-writing-unittest-cases-TDD-ok.png[,width="450", link="https://github.com/devonfw/devon-guide/wiki/images/writing-unittest-cases/getting-started-writing-unittest-cases-TDD-ok.png"]

Finally we have our first application implemented with TDD methodology!

As you can see, in this tutorial we have a very simple application, so we donâ€™t need another round of the TDD cycle, but in a real application, you may need to repeat this cycle more times to get a successful result.