:toc: macro
toc::[]

= CRUD Tutorial

In this tutorial we are going to learn the basic steps to create a simple CRUD using OASP4js.

== Using REST services

While it is possible to fit all the code for fetching, displaying and updating data stored at the server into a single .js file, the code is very difficult to maintain. In the sample application, the functionality is split in different files, e.g. for displaying the tables, we use the following files:

[width="80%",frame="topbot",options="header"]
|======================
|*file* |*functionality*
|table-mgmt.rest-service.js  |performs the calls of REST services
|tables.service.js           |prepares parameters for REST calls, provides the responses for the rest of the application
|table-search.controller.js  |controller of the page, uses the tables.service for CRUD operations on the table entities
|======================

A sample REST call for getting a table entity from the server uses the following code.

In the table-mgmt.rest.service.js, a 'tableManagementRestService' is created with a factory. Besides other services, it provides a function 'getTable' for retrieving a table by ID with GET.


    angular.module('app.table-mgmt').factory('tableManagementRestService', function ($http, currentContextPath) {
        'use strict';

        var servicePath = currentContextPath.get() + 'services/rest/tablemanagement/v1';

        return {
            getTable: function (id) {
                return $http.get(servicePath + '/table/' + id);
            },
    ...


In tables.service.js, another function called 'loadTable' is provided by a factory. There, the function of the REST service script is called and the data is returned.

    angular.module('app.table-mgmt').factory('tables', function (tableManagementRestService) {
        'use strict';
        var tables = [];
        return {
            ...
            loadTable: function (tableId) {
                return tableManagementRestService.getTable(tableId).then(function (response) {
                    return response.data;
                });
            },
    ...

In table-search.controller.js, the service 'tables' is included as an argument. Later, it can be used for getting a single table entity by using the 'loadTable' function provided by 'tables'.

    angular.module('app.table-mgmt')
        .controller('TableSearchCntl', function ($scope, tables, initialTableList, $modal, globalSpinner, offers, sales) {
    ...
    return tables.loadTable(tableRow.id);
    ...

== Displaying data and using pagination

At this point we have a services that give us the data that we are going to show to the user and process them. So in this part of the tutorial we are going to see how to show the data on the view.

Letâ€™s go to create a table grid with the data, for example a simple search view. For this, we need to create a table-search.controller.js file for the controller and a table-search.tpl.html file for the template.

Controller: table-search.controller.js

First of all we are going to prepare the data we are going to show in the view.

[source,java]
----
angular.module('app.table-mgmt')
   .controller('TableSearchCntl', function ($scope, tables, paginatedTableList, $state, globalSpinner) {
   'use strict';
   (...)

   $scope.maxSize = 5;
   $scope.totalItems = paginatedTableList.pagination.total;
   $scope.numPerPage = paginatedTableList.pagination.size;
   $scope.currentPage = paginatedTableList.pagination.page;

   $scope.gridOptions = {
      data: paginatedTableList.result
   };

   $scope.reloadTables = function () {
        tables.getPaginatedTables($scope.currentPage, $scope.numPerPage).then(function (paginatedTables) {
            return paginatedTables;
        }).then(function (res) {
            paginatedTableList = res;
            $scope.gridOptions.data = paginatedTableList.result;
        });
    };

    $scope.$watch('currentPage', function () {
            $scope.reloadTables();
        });

   (...)
}
----

As you can see, we have a lot of arguments in the controller: tables that have the services, paginatedTableList that help us with the pagination of the data and globalSpinner to show the spinner while the view is waiting for the service result.

With all this variables and methods, we can create a view to show the result of our REST service and update the data.

Template: +table-search.tpl.html+

[source,xml]
----
<table class="raw-table" tr-ng-grid=""
       selection-mode="SingleRow"
       enable-filtering="false"
       selected-items="selectedItems"
       items="gridOptions.data">
    <thead>
    <tr>
        <th field-name="number" display-name="Number" cell-width="7em"></th>
        <th field-name="state" display-name="State"></th>
        <th field-name="waiter" display-name="Waiter"></th>
    </tr>
    </thead>
</table>

<pagination total-items="totalItems" items-per-page="numPerPage" ng-model="currentPage" num-pages="numPages"
                    class="pagination-sm" boundary-links="true" rotate="false" max-size="maxSize"></pagination>
----

We are going to analyze the code by steps.

As you can see between the tag <table> we have the code to create a simple table Grid where we are going to display the data. The data displayed are in the variable gridOptions of the controller, this variable has the result of the service +getPaginatedTables+ that we need to create in the +table.services.js file+ as is mentioned in https://github.com/oasp/oasp4js/wiki/Tutorial-CRUD#using-rest-services[Using REST services].

[source,java]
----
angular.module('app.table-mgmt').factory('tables', function (tableManagementRestService) {
...
getPaginatedTables: function (pagenumber, pagesize) {
            return tableManagementRestService.getPaginatedTables(pagenumber, pagesize).then(function (response) {
                angular.copy(response.data, paginatedTables);
                return paginatedTables;
            });
        }
...
}
----

As you can see, we use the variables maxSize, totalItems, numPerPage and currentPage to add the pagination functionality to our view.

== Creating, reading and updating data

Let's go to add some functionality to our application, for example we can add some buttons to edit the table, or change the state to reserve, occupy or free and cancel the reservation.

To do this, we are going to help us with the component +button-bar+. So, we need to define a variable with the buttons in the controller.

[source,java]
----
(...)
$scope.buttonDefs = [
{
    label: 'TABLE_MGMT.EDIT',
    onClick: function () {
        $scope.openEditDialog(selectedTable());
    },
    isActive: function () {
        return selectedTable();
    }
},
{
    label: 'TABLE_MGMT.RESERVE',
    onClick: function () {
        globalSpinner.decorateCallOfFunctionReturningPromise(function () {
            var result = tables.reserve(selectedTable()).then($scope.reloadTables);
            $scope.selectedItems.length = 0;
            return result;
        });
    },
    isActive: function () {
        return selectedTable() && selectedTable().state === 'FREE';
    }
},
{
    label: 'TABLE_MGMT.CANCEL_RESERVATION',
    onClick: function () {
        globalSpinner.decorateCallOfFunctionReturningPromise(function () {
            var result = tables.cancelReservation(selectedTable()).then($scope.reloadTables);
            $scope.selectedItems.length = 0;
            return result;
        });
    },
    isActive: function () {
        return selectedTable() && selectedTable().state === 'RESERVED';
    }
},
{
    label: 'TABLE_MGMT.OCCUPY',
    onClick: function () {
        globalSpinner.decorateCallOfFunctionReturningPromise(function () {
            var result = tables.occupy(selectedTable()).then($scope.reloadTables);
            $scope.selectedItems.length = 0;
            return result;
        });
    },
    isActive: function () {
        return selectedTable() && (selectedTable().state === 'RESERVED' || selectedTable().state === 'FREE');
    }
},
{
    label: 'TABLE_MGMT.FREE',
    onClick: function () {
        globalSpinner.decorateCallOfFunctionReturningPromise(function () {
            var result = tables.free(selectedTable()).then($scope.reloadTables);
            $scope.selectedItems.length = 0;
            return result;
        });
    },
    isActive: function () {
        return selectedTable() && selectedTable().state === 'OCCUPIED';
    }
}
];
(...)
----

As you can see, the button has three attributes, label that the button will display, onClick that is the method we call with the event onClick and isActive to determine when the button need to be active or disable.

Now we need to add this buttons in the view, this is very simple

[source,xml]
----
<button-bar is-label-translatable="true" button-defs="buttonDefs"></button-bar>
----

[NOTE]
We are using TABLE_MGMT in this tutorial as i18n file of the table-mgmt component.
