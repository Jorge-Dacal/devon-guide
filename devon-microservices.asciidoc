:toc: macro
toc::[]

= Microservices in Devonfw

== Introduction
The Microservices architecture is an approach for application development based on a series of _small_ services grouped under a business domain. Each individual service runs autonomously and communicating with each other through their APIs. That independence between the different services allows to manage (upgrade, fix, deploy, etc.) each one without affecting the rest of the system's services. In addition to that the microservices architecture allows to escalate specific services when facing an increment of the requests, so the applications based on microservices are more flexible and stable, and can be adapted quickly to demand changes.

However, this new approach, developing apps based on microservices, presents some downsides. To address those, Devonfw microservices approach is based on http://cloud.spring.io/spring-cloud-netflix/[Spring Cloud Netflix], that provides all the main components for microservices integrated within Spring Boot context.   

Let's see the main challenges when working with microservices:

-  Having the applications divided in different services we will need a component (router) to redirect each request to the related microservice. These redirection rules must implement filters to guarantee a proper functionality.

- In order to manage correctly the routing process, the application will also need a catalog with all the microservices and its details: IPs and ports of each of the deployed instances of each microservice, the state of each instance and some other related information. This catalog is called _Service Discovery_.

- With all the information of the _Service Discovery_ the application will need to calculate and select between all the available instances of a microservice which is the suitable one. This will be figured out by the library _Client Side Load Balancer_.

- The different microservices will be likely interconnected with each other, that means that in case of failure of one of the microservices involved in a process, the application must implement a mechanism to avoid the error propagation through the rest of the services and provide an alternative as a process result. To solve this, the pattern _Circuit Breaker_ can be implemented in the calls between microservices.

- As we have mentioned, the microservices will exchange calls and information with each other so our applications will need to provide a secured context to avoid not allowed operations or intrusions. In addition, since microservices must be able to operate in an isolated way, it is not recommended to maintain a session. To meet this need without using Spring sessions, a token-based authentication is used that exchanges information using the https://jwt.io/[json web token (JWT)] protocol.

In addition to all of this we will find other issues related to this particular architecture that we will address fitting the requirements of each project.

- Distributed data bases: each instance of a microservice should have only one data base.

- Centralized logs: each instance of a microservice creates a log and a trace that should be centralized to allow an easier way to read all that information.

- Centralized configuration: each microservice has its own configuration, so our applications should group all those configurations in only one place to ease the configuration management.

- Automatized deployments: as we are managing several components (microservices, catalogs, balancers, etc.) the deployment should be automatized to avoid errors and ease this process.

== Microservices schema

In the following schema we can see an overview of the structure of components in a Devon application based on the _Spring Cloud Netflix_ solution for microservices.

image::images/microservices/microservices_01.png[,width="450", link="images/microservices/microservices_01.png"]

Let's explain each component

=== Service Discovery - Eureka

http://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.3.0.M1/#_service_discovery_eureka_clients[Eureka] is a server to register and locate the microservices. The main function for _Eureka_ is to register the different instances of the microservices, its location, its state and other metadata.

It works in a simple way, during the start of each microservice, this communicates with the _Eureka_ server to notify its availability and to send the metadata. The microservice will continue to notify its status to the Eureka server every 30 seconds (default time on Eureka server properties). This value can be changed in the configuration of the component.

If after 3 periods, Eureka does not receive notification of any of the microservices, it will be considered as unavailable and will eliminate its registration.

In addition, it serves as a catalog to locate a specific microservice when routing a request to it.

=== Circuit Breaker - Hystrix
http://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.3.0.M1/#_circuit_breaker_hystrix_clients[Hystrix] is a library that implements the https://martinfowler.com/bliki/CircuitBreaker.html[Circuit Breaker] pattern. Its main functionality is to improve the reliability of the system, isolating the entry points of the microservices, preventing the cascading failure from the lower levels of the application all the way up to the user.

In addition to that, it allows developers to provide a fallback in case of error. _Hystrix_ manages the requests to a service, and in case that the microservice doesn't response, allows to implement an alternative to the request.

=== Client Side Load Balancer - Ribbon

http://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.3.0.M1/#spring-cloud-ribbon[Ribbon] is a library designed as client side load balancer. Its main feature is to integrate with _Eureka_ to discover the instances of the microservices and their metadata. In that way the _Ribbon_ is able to calculate which of the available instances of a microservice is the most appropriate for the client, when facing a request.

=== REST Client - Feign
http://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.3.0.M1/#spring-cloud-feign[Feign] is a REST client to make calls to other microservices. The strength of Feign is that it integrates seamlessly with _Ribbon_ and _Hystrix_, and its implementation is through annotations, which greatly facilitates this task to the developer.

Using annotations, Spring-cloud generates, automatically, a fully configured REST client.

=== Router and Filter - Zuul

http://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.3.0.M1/#_router_and_filter_zuul[Zuul] is the entry point of the apps based on Spring-cloud microservices. It allows dynamic routing, load balancing, monitoring and securing of requests. By default _Zuul_ uses _Ribbon_ to locate, through Eureka, the instances of the microservice that it wants to invoke and sends the requests within a _Hystrix Command_, taking advantage of its functionality.

== How to create microservices in Devonfw

In order to generate microservices in a Devonfw project we can choose between two approaches:

- generate a new OASP4J application and implement one by one all the needed components (based on Spring Cloud).

- generate a new OASP4J application through the custom microservice archetype included in the Devonfw distributions.

That second approach, using the Devonfw microservices archetype, will generate automatically all the basic structure and components to start developing the microservices based application.

=== Devonfw archetypes

To simplify starting with projects based on microservices, Devonfw includes two archetypes to generate pre-configured projects that include all the basic components of the _Spring Cloud_ implementation.

- *archetypes-microservices-infra*: generates a project with the needed infrastructure services to manage microservices. Includes the _Eureka_ service, _Zuul_ service and the authentication service.

- *archetypes-microservices*: generates a simple project pre-configured to work as a microservice.

=== Create New Microservices infrastructure application

To generate a new microservices infrastructure application through the Devonfw archetype you only need to open a Devonfw console (_console.bat_ script) and follow the same steps described in link:getting-started-creating-new-devonfw-application[getting started creating new devonfw application]. But, instead of using the _standard_ archetype, we must provide the special infrastructure archetype `archetype-microservice-infra`. Remember to provide your own values for _DgroupId_, _DartifactId_, _Dversion_ and _Dpackage_ parameters:

[source, bash]
----
mvn -DarchetypeVersion=2.1.0 -DarchetypeGroupId=com.capgemini.devonfw.archetypes -DarchetypeArtifactId=archetype-microservices-infra archetype:generate -DgroupId=com.capgemini -DartifactId=sampleinfra -Dversion=0.1-SNAPSHOT -Dpackage=com.capgemini.sampleinfra
----

Once the _Maven_ command has finished an application with the following modules should be created:

image::images/microservices/microservices_02.png[,width="250", link="images/microservices/microservices_02.png"]

==== service-eureka module

This module contains the needed classes and configuration to start a _Eureka_ server. 

This service runs by default on port _8761_ although ti can be changed in the `application.properties` file of the project.

==== service-zuul module

This module contains all the needed classes and configuration to start a _Zuul_ server, that will be in charge of the routing and filter of the requests.

This service by default runs on port _8081_ but, as we already mentioned, it can be changed through the file `application.properties` of the project.

==== service-auth module

This module runs an authentication and authorization microservice that allows to generate a security token to make calls to the rest of microservices. This module is only providing a basic structure, the security measures must be implemented fitting the requirements of each project.

This service runs by default on port _9999_, although, as in previous services, it can be edited in the `application.properties` file.

=== Create New Microservices Application 

To generate a new microservice project through the Devonfw archetype, as in previous archetype example, you can follow the instructions explained in link:getting-started-creating-new-devonfw-application[getting started creating new devonfw application]. But, instead of using the _standard_ archetype, we must provide the special microservices archetype `archetype-microservices`. Open a Devonfw console (_console.bat_ script) and launch a _Maven_ command like the following (provide your own values for _DgroupId_, _DartifactId_, _Dversion_ and _Dpackage_ parameters):

[source, bash]
----
mvn -DarchetypeVersion=2.1.0 -DarchetypeGroupId=com.capgemini.devonfw.archetypes -DarchetypeArtifactId=archetype-microservices archetype:generate -DgroupId=com.capgemini -DartifactId=sampleapp1 -Dversion=0.1-SNAPSHOT -Dpackage=com.capgemini.sampleapp1
----

That command generates a simple application containing the source code for the microservice. By default, the `pom.xml` includes the `devon-microservices` module, that contains the security configuration, jwt interceptors, _Hystrix_, _Ribbon_ and _FeignClient_ configuration and some properties common to all microservices.

The created microservice runs by default on port _9091_ and has the `context-path` with the same name than the project. This parameters can be changed through the 'application.properties' file of the project.

== How to use microservices in Devonfw

In the following sections we are going to provide some patterns to manage microservices in Devonfw using the archetype, alongside the options that each of the available modules offer.

=== Eureka service

We are going to review the general options for the _Eureka_ service. If you are interested in getting more details you can visit the official site for http://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.3.0.M1/#_service_discovery_eureka_clients [Spring Cloud Eureka clients].

To create an _Eureka_ server you only need to create a new _Spring Boot_ application and add the `@EnableEurekaServer` to the main class.

[NOTE]
====
The provided archetype `archetype-microservices-infra` already provides that annotated class.
====

[source, java]
----
@Configuration
@EnableEurekaServer
@EnableAutoConfiguration
@SpringBootApplication
public class EurekaBootApp {

  public static void main(String[] args) {

    new SpringApplicationBuilder(EurekaBootApp.class).web(true).run(args);
  }
}
----

The basic properties that must be configured for _Eureka_ server are:

- port: in which port the service will run. The default port is the _8761_ and you have to keep in mind that the connection to this port is specially critical as all the microservices must be able to connect to this `host:port`. Remember that _Eureka_ generates and manages the microservices catalog, so it`s crucial to allow the microservices to register in this component.

- url: which _URL_ manages as area.

....
eureka.instance.hostname=localhost
eureka.instance.port=8761

server.port=${eureka.instance.port}

eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${eureka.instance.port}/eureka/
....

The way to connect a microservice to _Eureka_ server is really simple. You only will need to specify the `host:port` where the server is located and annotate the _Spring Boot_ class with `@EnableMicroservices` annotation.

[NOTE]
====
Instead of using that `@EnableMicroservices` annotation, you can use the equivalent _Spring_ annotations `@EnableDiscoveryClient` or `@EnableEurekaClient`. 
====

[source,java]
----
@Configuration
@EnableMicroservices
@SpringBootApplication
public class MicroserviceBootApp {
  public static void main(String[] args) {

    SpringApplication.run(MicroserviceBootApp.class, args);
  }
}
----

....
eureka.instance.hostname=localhost
eureka.instance.port=8761

eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${eureka.instance.port}/eureka/
....

With this the application will register automatically in _Eureka_ and will be validated each 30 seconds. This value can be changed editing the property `eureka.instance.leaseRenewalIntervalInSeconds` in `application.properties` file. It must be taken into account that each _Eureka_ client will maintain a cache of _Eureka_ records to avoid calling the service every time it is necessary to access another microservice. This cache is reloaded every 30 seconds, this value can also be edited through property `eureka.client.registryFetchIntervalSeconds` in `application.properties` file.