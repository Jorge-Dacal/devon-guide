:toc: macro
toc::[]

# The Long Web Request module

== Implementation based on Continuations

The Long Web Request Module has been implemented as asynchronous support for manage long processes in the server side based on the REST service of the oasp4j based applications. The module implements the Apache CXF Continuations API, for more information you can visit link:http://cxf.apache.org/docs/continuations.html[this link].

The continuations API enables the server to suspend the request thread and resume it later, when the long running process is over, offering a scalability advantage because suspended request threads are back to the HTTP request handling thread pool, being able to serve other client requests.

=== Adding the dependency to a project
To get access to the functionality of the Long Web Request module you only need to include the module as a dependency in your project's pom.xml

[source,xml]
----
 <dependency>
    <groupId>com.capgemini.devonfw.modules</groupId>
    <artifactId>devonfw-longwebrequest</artifactId>
    <version>2.1.0-SNAPSHOT</version>
</dependency>
----

=== Injecting the module in our REST service

First of all we will need to add the scanner for dependency injection. To do so, in the _SpringBoot_ main class, we must add the following annotations

[source,java]
----
@Configuration
@ComponentScan(basePackages = { "com.capgemini.devonfw.module.longwebrequest" })
@EnableAutoConfiguration
public class MyBootApp {

    [...]
----

[NOTE]
====
Depending on your project tree structure you may need to specify also the location for your Rest service:

`@ComponentScan(basePackages = { "com.capgemini.devonfw.module.longwebrequest", "my.rest.location.package" })`

====

As you can see the `basePackages` of the `@ComponentScan` points to the Long Web Request module package so now we can start using the module.


Finally we can inject the _LongWebRequest_ module in our REST service using the `@Inject` annotation (`@Autowire` should also work) and relating it to a `private` property of the class.

[source,java]
----
import com.capgemini.devonfw.module.longwebrequest.common.api.LongWebRequest;

...

@Service("myRestService")
@Path("/rest")
public class Rest {

  @Inject
  private LongWebRequest lwr;

  @GET
  @Path("/do_large_task")
  @Produces(MediaType.TEXT_PLAIN)
  public String doLargeTask() {

	[...]


----

=== Basic usage
In order to use the module functionality you will need to complete three steps

==== Step 1: Implement a `LongTask`class 

Wrap your long process in the `run` method of a class that implements the `LongTask` interface, provided with the _Long Web Request_ module. The only particularity of that interface is the implementation of that `run()` method that will be used by the module in its internal process.

[source,java]
----
import com.capgemini.devonfw.module.longwebrequest.common.api.LongTask;

...

public class MyLongTask implements LongTask {

  @Override
  public Object run() {

      // here goes the code for my long process
      return "Done!"
  }

  ...

----

==== Step 2: Import the context

To obtain the _Continuation_ object we need to provide the _context_ of the request. To do that we only need to add the `MessageContext` object in our service, using the `@Context` annotation:

[source,java]
----
import com.capgemini.devonfw.module.longwebrequest.common.api.LongWebRequest;
import org.apache.cxf.jaxrs.ext.MessageContext;

...

@Service("myRestService")
@Path("/rest")
public class Rest {

  @Inject
  private LongWebRequest lwr;

  @Context
  private MessageContext context;

  @GET
  @Path("/do_large_task")
  @Produces(MediaType.TEXT_PLAIN)
  public String doLargeTask() {

	[...]


----


==== Step 3: Call the module

To call the module you only need to use the `execute()` method and provide the `context` obtained in the previous step and the `LongTask` class that you implemented in the first step:


[source,java]
----
import com.capgemini.devonfw.module.longwebrequest.common.api.LongWebRequest;
import org.apache.cxf.jaxrs.ext.MessageContext;

...

@Service("myRestService")
@Path("/rest")
public class Rest {

  @Inject
  private LongWebRequest lwr;

  @Context
  private MessageContext context;

  @GET
  @Path("/do_large_task")
  @Produces(MediaType.TEXT_PLAIN)
  public String doLargeTask() {

	return (String) this.lwr.execute(this.context, new MyLongTask());
  }

----

=== Passing parameters to the Long Task class

In case you need it you can pass parameters to the class that wraps the long process.

[source,java]
----
public class MyLongTask implements LongTask {

  private String id;

  public MyLongTask(String id) {
    this.id = id;
  }

  @Override
  public Object run() {

      // here goes the code for my long process
      doLargeTaskUsingTheParameter(this.id);
      return "Done!"
  }

}
----

And the call from the Rest service would be

[source,java]
----

  ...

  @GET
  @Path("/getsomething/{id}")
  @Produces(MediaType.TEXT_PLAIN)
  public String getSomething(@PathParam("id") String id) {

    return (String) this.lwr.execute(this.context, new MyLongTask(id));
  }

  ...

----


=== Configuring the LongWebRequest object

Internally the `Continuation` process can be configured in three parameters:

- *time out*: The amount of time that the process will wait for our long task to be finished before return. A timeout of < 0 will cause an immediate return of the process. A timeout of 0 will wait indefinitely.

- *core pool size*: Sets the ThreadPoolExecutor's core pool size.

- *max pool size*: Sets the ThreadPoolExecutor's maximum pool size.


The default instance of the LongWebRequest is provided with the values:

- time out: 0.

- core pool size: 5.

- max pool size: 5.


However you can configure those values using the alternative constructors of the `LongWebRequest` object:

[source,java]
----
  
  ...

  @GET
  @Path("/do_large_task")
  @Produces(MediaType.TEXT_PLAIN)
  public String doLargeTask() {

  	// for a time out of 6 seconds and a core pool size and maximum pool size of 10:
	LongWebRequest myLongWR = new LongWebRequestImpl(6000, 10, 10);
    return (String) myLongWR.execute(this.context, new MyLongTask());
  }

  ...

----





== Implementation based on JAX-RS async API

Asynchronous processing in server side and client side is a new feature that is offered by the JAX-RS 2.0.

In synchronous request/response processing model, client connection is accepted and processed in a single I/O thread by the server. Normally a pool of such I/O threads is available at server side. So when a request is received, the server dedicates one of these threads to accept and process the request. The thread blocks until the processing is finished and returned.

The idea behind asynchronous processing model is to separate connection accepting and request processing operations. Technically speaking it means to allocate two different threads, one to accept the client connection (acceptor) and the other to handle heavy and time consuming operations (worker) releasing the first one.

=== Adding the dependency to a project
To get access to the functionality of the async module you will need to include its dependency in your project's pom.xml

[source,xml]
----
 <dependency>
    <groupId>com.capgemini.devonfw.modules</groupId>
    <artifactId>devonfw-longwebrequest</artifactId>
    <version>2.1.0-SNAPSHOT</version>
</dependency>
----

=== Injecting the module

Add the reference to the module in your REST service using the `@Inject` annotation

[source,java]
----
import com.capgemini.devonfw.module.longwebrequest.common.api.LongWebRequest;

...

@Service("myRestService")
@Path("/rest")
public class Rest {

  @Inject
  private Async async;

	[...]


----

Remember to add the package of the module to the `@ComponentScan` annotation in the Spring Boot main class.

[source,java]
----
@ComponentScan(basePackages = { "com.capgemini.devonfw.module.longwebrequest" , "my.rest.location.package" }
----


=== Call the module
Before calling the module you will need to complete two previous steps:

- Wrap your long process in the _run_ method of a class that implements the `AsyncTask`.

[source,java]
----
public class MyAsyncTask implements AsyncTask {

  @Override
  public Object run() {

  	// Here your code for long process
  }

}
----

- provide an Async Response, to do so use the `@Suspended` annotation and add the `AsyncResponse` object to your REST method.

Now you can call the module using its _execute_ method. The request will be binded to the async response and the async task provided.

The call will be like the following 

[source,java]
----
import com.capgemini.devonfw.module.longwebrequest.common.api.LongWebRequest;
import javax.ws.rs.container.AsyncResponse;
import javax.ws.rs.container.Suspended;
...

@Service("myRestService")
@Path("/rest")
public class Rest {

  @Inject
  private Async async;

  @GET
  @Path("/asynctask")
  @Produces(MediaType.TEXT_PLAIN)
  public void asyncTask(@Suspended final AsyncResponse response) {

    this.async.execute(response, new MyAsyncTask());
  }
----

=== Passing parameters

You also can pass parameters to be used in the long task process.

In this case the module call would be

[source,java]
----
  @GET
  @Path("/asynctask/{id}")
  @Produces(MediaType.TEXT_PLAIN)
  public void asyncTask(@Suspended final AsyncResponse response, @PathParam("id") String id) {

    this.async.execute(response, new MyAsyncTask(id));
  }
----

And the wrapper class

[source,java]
----
public class MyAsyncTask implements AsyncTask {

  private String id;

  public MyAsyncTask(String id) {
    this.id = id;
  }

  @Override
  public Object run() {

  	// Here your code for long process with access to 'this.id'
  }

}
----

=== Module Configuration

Internally the Async module process can be configured in two main parameters:

- *core pool size*: Sets the ThreadPoolExecutor's core pool size.

- *time out*: The amount of time that the process will wait for our long task to be finished before return. A timeout of < 0 will cause an immediate return of the process. A timeout of 0 will wait indefinitely.


The default values provided in the module are:

- core pool size: 10.

- time out:

  * milliseconds: 0.
  * status: 503 , service unavailable (available status 400,403,404,500 and 503).
  * response Content: Operation timeout (the time out response message).
  * mediatype: text/plain (you can response the timeout in json, xml, html, etc. formats).

However you can edit those values by overriding the configuration properties in your app. To do it you can use the `application.properties` to add the properties you want to define.

| Property | Application Property Name |
| -------- | ------------------------- |
| core pool size | devonfw.async.corePoolSize |
| time out milliseconds | devonfw.async.timeout.milliseconds |
| time out status | devonfw.async.timeout.status |
| time out response content | devonfw.async.timeout.responseContent |
| time out media type | devonfw.async.timeout.mediatype |

As example, the next could be a valid `application.properties` configuration file for an application in which we want an async process with a _core pool size_ of 20, and a _timeout_ of 10 seconds returning with a status of 500 (internal server error) and a response in _json_ format:

[source,java]
----
devonfw.async.corePoolSize=20
devonfw.async.timeout.milliseconds=10000
devonfw.async.timeout.status=500
devonfw.async.timeout.mediatype=application/json
devonfw.async.timeout.responseContent={"response":[{"message":"error", "cause":"time out"}]}
----

